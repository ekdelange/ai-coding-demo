<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Actuator Tariff Impact Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator.min.css">
  <style>
    :root {
      --brand:#e9a16f;
      --sidebar:#f5c6a5;
      --panel:#fff7f1;
      --text:#333;
      --muted:#666;
      --bg:#fdf8f3;
      --accent:#d68553;
    }
    * { box-sizing: border-box; }
    body {
      margin:0;
      font-family: "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    header {
      background: white;
      border-bottom: 4px solid var(--brand);
      padding: 0.75rem 1.5rem;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      position: sticky;
      top:0;
      z-index: 10;
    }
    header h1 {
      margin:0;
      font-size: 1.4rem;
      color: var(--brand);
      letter-spacing: 0.03em;
    }
    .toolbar {
      display: flex;
      align-items: center;
      gap:0.75rem;
      flex-wrap: wrap;
    }
    .toolbar label {
      display:flex;
      align-items:center;
      gap:0.5rem;
      font-size:0.9rem;
      background: var(--panel);
      padding:0.35rem 0.75rem;
      border-radius:999px;
      border:1px solid rgba(0,0,0,0.08);
    }
    .toolbar button, .toolbar .download-menu button {
      background: var(--brand);
      color:white;
      border:none;
      border-radius:999px;
      padding:0.45rem 0.95rem;
      font-size:0.9rem;
      cursor:pointer;
      transition: background 0.2s;
    }
    .toolbar button:hover {
      background: var(--accent);
    }
    .download-menu {
      position: relative;
    }
    .download-options {
      position: absolute;
      top: calc(100% + 6px);
      right:0;
      background:white;
      border:1px solid rgba(0,0,0,0.15);
      border-radius:0.5rem;
      box-shadow:0 8px 20px rgba(0,0,0,0.08);
      min-width:180px;
      display:none;
      flex-direction:column;
      overflow:hidden;
      z-index:20;
    }
    .download-options button {
      border-radius:0;
      border:none;
      background:white;
      color:var(--text);
      padding:0.5rem 0.75rem;
      text-align:left;
    }
    .download-options button:hover {
      background:var(--panel);
    }
    .download-menu.open .download-options {
      display:flex;
    }
    #layout {
      display:grid;
      grid-template-columns: 290px minmax(0,1fr) 300px;
      gap:1rem;
      padding:1rem;
    }
    aside {
      background: var(--sidebar);
      padding:1rem;
      border-radius:0.75rem;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.08);
      display:flex;
      flex-direction:column;
      gap:1.25rem;
      position:relative;
    }
    .panel {
      background: var(--panel);
      border-radius:0.75rem;
      padding:1rem;
      box-shadow:0 4px 16px rgba(0,0,0,0.06);
    }
    .panel h2 {
      margin-top:0;
      font-size:1.05rem;
      color:var(--accent);
    }
    .section-title {
      font-weight:600;
      text-transform:uppercase;
      letter-spacing:0.04em;
      font-size:0.75rem;
      color:var(--muted);
      margin-bottom:0.35rem;
    }
    .control-group {
      display:flex;
      flex-direction:column;
      gap:0.4rem;
    }
    .control-group label {
      font-size:0.9rem;
      display:flex;
      align-items:center;
      gap:0.35rem;
      cursor:pointer;
    }
    .control-group input[type="radio"],
    .control-group input[type="checkbox"] {
      accent-color: var(--brand);
    }
    main {
      display:flex;
      flex-direction:column;
      gap:1rem;
    }
    .card {
      background:var(--panel);
      border-radius:0.75rem;
      padding:1rem;
      box-shadow:0 4px 16px rgba(0,0,0,0.05);
    }
    #top-bar {
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      gap:0.75rem;
    }
    #sku-select {
      min-width:220px;
      padding:0.4rem 0.6rem;
      border-radius:0.5rem;
      border:1px solid rgba(0,0,0,0.15);
      font-size:0.95rem;
    }
    #row-counts {
      font-size:0.9rem;
      color:var(--muted);
    }
    .kpi-grid {
      display:grid;
      grid-template-columns: repeat(auto-fit,minmax(160px,1fr));
      gap:0.75rem;
    }
    .kpi-tile {
      background:white;
      border-radius:0.75rem;
      padding:0.75rem 1rem;
      border:1px solid rgba(0,0,0,0.08);
      display:flex;
      flex-direction:column;
      gap:0.35rem;
    }
    .kpi-label {
      font-size:0.8rem;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:0.05em;
    }
    .kpi-value {
      font-size:1.3rem;
      font-weight:600;
      color:var(--brand);
    }
    #cost-chart, #map-chart, #whatif-scatter {
      width:100%;
      min-height:320px;
    }
    #sku-table {
      height:360px;
    }
    .tabs {
      display:flex;
      gap:0.5rem;
      margin-bottom:0.5rem;
    }
    .tabs button {
      border:none;
      padding:0.5rem 1rem;
      border-radius:0.75rem;
      background:white;
      box-shadow:0 2px 6px rgba(0,0,0,0.06);
      cursor:pointer;
      transition:all 0.2s;
      color:var(--muted);
    }
    .tabs button.active {
      background:var(--brand);
      color:white;
      box-shadow:0 4px 12px rgba(0,0,0,0.12);
    }
    .tab-pane { display:none; }
    .tab-pane.active { display:block; }
    #insights-panel {
      display:flex;
      flex-direction:column;
      gap:1rem;
    }
    #insights-panel .panel {
      flex:1;
    }
    #insights-text {
      font-size:0.95rem;
      line-height:1.5;
      color:var(--text);
    }
    #warnings {
      font-size:0.85rem;
      color:#a33;
      display:flex;
      flex-direction:column;
      gap:0.35rem;
    }
    .legend {
      display:flex;
      flex-wrap:wrap;
      gap:0.5rem;
      margin-top:0.5rem;
      font-size:0.85rem;
      color:var(--muted);
    }
    .legend span {
      display:flex;
      align-items:center;
      gap:0.35rem;
    }
    .legend .color-box {
      width:12px;
      height:12px;
      border-radius:2px;
      display:inline-block;
    }
    #json-modal {
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.45);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:50;
      padding:1rem;
    }
    #json-modal .modal-content {
      background:white;
      border-radius:0.75rem;
      max-width:640px;
      width:100%;
      padding:1rem;
      display:flex;
      flex-direction:column;
      gap:0.75rem;
    }
    #json-modal textarea {
      width:100%;
      min-height:220px;
      padding:0.75rem;
      border-radius:0.5rem;
      border:1px solid rgba(0,0,0,0.15);
      font-family:monospace;
      font-size:0.9rem;
    }
    #json-modal.hidden {
      display:none;
    }
    .modal-actions {
      display:flex;
      justify-content:flex-end;
      gap:0.5rem;
    }
    .fx-table {
      width:100%;
      border-collapse:collapse;
      font-size:0.85rem;
    }
    .fx-table th,
    .fx-table td {
      border:1px solid rgba(0,0,0,0.08);
      padding:0.35rem 0.5rem;
      text-align:left;
    }
    .fx-table th {
      background:var(--sidebar);
    }
    @media (max-width: 1200px) {
      #layout {
        grid-template-columns: 260px minmax(0,1fr);
        grid-template-areas:
          "sidebar main"
          "sidebar right";
      }
      #insights-panel { grid-area:right; }
    }
    @media (max-width: 880px) {
      header { position:static; }
      #layout {
        grid-template-columns: 1fr;
      }
      aside { order:1; }
      main { order:2; }
      #insights-panel { order:3; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Actuator Tariff Impact Dashboard</h1>
    <div class="toolbar">
      <label>
        <span>Upload workbook</span>
        <input id="file-input" type="file" accept=".xlsx,.xls,.csv,.zip" />
      </label>
      <button id="paste-json-btn" type="button">Paste JSON</button>
      <button id="reset-overrides-btn" type="button">Reset Overrides</button>
      <div class="download-menu" id="download-menu">
        <button type="button" id="download-btn">Download CSV/XLSX</button>
        <div class="download-options">
          <button type="button" data-format="csv">Download filtered CSV</button>
          <button type="button" data-format="xlsx">Download filtered XLSX</button>
        </div>
      </div>
    </div>
  </header>
  <div id="layout">
    <aside>
      <div>
        <div class="section-title">Scenario Date</div>
        <div class="control-group" id="scenario-options"></div>
      </div>
      <div>
        <div class="section-title">Final Assembly Site</div>
        <div class="control-group" id="assembly-options"></div>
      </div>
      <div>
        <label class="control-group" style="flex-direction:row; align-items:center; gap:0.5rem;">
          <input type="checkbox" id="include-fixed" />
          <span>Include fixed logistics fees (per 10’000 units)</span>
        </label>
      </div>
      <div>
        <div class="section-title">Tariff overrides</div>
        <div id="tariff-table" style="height:260px;"></div>
      </div>
      <div>
        <div class="section-title">Warnings</div>
        <div id="warnings"></div>
      </div>
    </aside>
    <main>
      <div class="card">
        <div id="top-bar">
          <div>
            <label for="sku-select" class="section-title" style="display:block; margin-bottom:0.25rem;">SKU</label>
            <select id="sku-select"></select>
          </div>
          <div id="row-counts">Waiting for data…</div>
        </div>
      </div>
      <div class="card" id="kpi-card">
        <div class="section-title">Key metrics</div>
        <div class="kpi-grid" id="kpi-grid"></div>
      </div>
      <div class="card">
        <div class="section-title">Cost mix by assembly site</div>
        <div id="cost-chart"></div>
        <div class="legend" id="assembly-legend"></div>
      </div>
      <div class="card">
        <div class="section-title">Per-SKU landed cost breakdown</div>
        <div id="sku-table"></div>
      </div>
      <div class="card">
        <div class="tabs">
          <button type="button" class="active" data-tab="map-tab">Map</button>
          <button type="button" data-tab="whatif-tab">What-if</button>
        </div>
        <div class="tab-pane active" id="map-tab">
          <div id="map-chart"></div>
        </div>
        <div class="tab-pane" id="whatif-tab">
          <div class="control-group" style="margin-bottom:0.75rem; max-width:320px;">
            <label style="font-weight:600;">Motor routing override</label>
            <select id="motor-route" style="padding:0.4rem 0.5rem; border-radius:0.5rem; border:1px solid rgba(0,0,0,0.15);">
              <option value="default">Use workbook origins</option>
              <option value="Switzerland">Route motors from Switzerland</option>
              <option value="United States">Route motors from United States</option>
              <option value="Mexico">Route motors from Mexico</option>
            </select>
          </div>
          <div id="whatif-scatter"></div>
        </div>
      </div>
    </main>
    <div id="insights-panel">
      <div class="panel">
        <h2>Insights</h2>
        <div id="insights-text">Upload a workbook to explore landed cost insights.</div>
      </div>
      <div class="panel">
        <h2>FX snapshot (for reference)</h2>
        <table class="fx-table" id="fx-table"></table>
      </div>
    </div>
  </div>
  <div id="json-modal" class="hidden">
    <div class="modal-content">
      <h2>Paste JSON rows</h2>
      <p style="margin:0; font-size:0.9rem; color:var(--muted);">Paste an object with sheet names as keys (Products, BOM, …). Existing data will be replaced.</p>
      <textarea id="json-input" placeholder='{"Products":[{"SKU":"ACTUATOR_AX100",...}]}'></textarea>
      <div class="modal-actions">
        <button type="button" id="cancel-json" style="background:#ddd; color:#333; border-radius:0.5rem; padding:0.4rem 0.9rem; border:none; cursor:pointer;">Cancel</button>
        <button type="button" id="load-json" style="background:var(--brand); color:white; border-radius:0.5rem; padding:0.4rem 0.9rem; border:none; cursor:pointer;">Load</button>
      </div>
    </div>
  </div>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/tabulator-tables@5.5.2/dist/js/tabulator.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    const state = {
      data: {},
      selection: {
        scenarioDate: null,
        assemblySite: 'BU_CH_MUR',
        includeFixedFees: false,
        sku: 'ALL',
        motorRoute: 'default'
      },
      overrideMap: new Map(),
      tables: {
        tariff: null,
        sku: null
      },
      charts: {
        cost: null,
        map: null,
        whatIf: null
      },
      warnings: [],
      colors: {
        'BU_CH_MUR': '#e9a16f',
        'PLANT_US_MI': '#5a6cb2',
        'PLANT_MX_NL': '#8ab17d'
      }
    };

    const requiredSheets = ['Products','BOM','Components','Sites','AssemblyOptions','LogisticsLanes','TariffScenarios','Tariffs_US','TariffInputs','MapNodes','FX'];

    document.getElementById('file-input').addEventListener('change', onFileSelected);
    document.getElementById('include-fixed').addEventListener('change', (ev) => {
      state.selection.includeFixedFees = ev.target.checked;
      recomputeAndRender();
    });
    document.getElementById('sku-select').addEventListener('change', (ev) => {
      state.selection.sku = ev.target.value;
      renderAll();
    });
    document.getElementById('motor-route').addEventListener('change', (ev) => {
      state.selection.motorRoute = ev.target.value;
      recomputeAndRender();
    });
    document.getElementById('paste-json-btn').addEventListener('click', () => {
      document.getElementById('json-modal').classList.remove('hidden');
    });
    document.getElementById('cancel-json').addEventListener('click', () => {
      document.getElementById('json-input').value = '';
      document.getElementById('json-modal').classList.add('hidden');
    });
    document.getElementById('load-json').addEventListener('click', () => {
      const text = document.getElementById('json-input').value.trim();
      if (!text) {
        alert('Paste JSON before loading.');
        return;
      }
      try {
        const parsed = JSON.parse(text);
        if (typeof parsed !== 'object') throw new Error('JSON must be an object of sheet arrays.');
        state.data = {};
        for (const [key, value] of Object.entries(parsed)) {
          if (Array.isArray(value)) {
            state.data[key] = value;
          }
        }
        document.getElementById('json-modal').classList.add('hidden');
        document.getElementById('json-input').value = '';
        afterDataLoaded();
      } catch (err) {
        alert('Invalid JSON: ' + err.message);
      }
    });
    document.getElementById('reset-overrides-btn').addEventListener('click', () => {
      resetOverrides();
    });

    const downloadMenu = document.getElementById('download-menu');
    document.getElementById('download-btn').addEventListener('click', () => {
      downloadMenu.classList.toggle('open');
    });
    downloadMenu.querySelectorAll('.download-options button').forEach(btn => {
      btn.addEventListener('click', () => {
        const format = btn.dataset.format;
        triggerDownload(format);
        downloadMenu.classList.remove('open');
      });
    });
    document.addEventListener('click', (ev) => {
      if (!downloadMenu.contains(ev.target)) {
        downloadMenu.classList.remove('open');
      }
    });

    document.querySelectorAll('.tabs button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tabs button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
        document.getElementById(btn.dataset.tab).classList.add('active');
        if (btn.dataset.tab === 'map-tab' && state.charts.map) {
          Plotly.Plots.resize('map-chart');
        }
        if (btn.dataset.tab === 'whatif-tab' && state.charts.whatIf) {
          Plotly.Plots.resize('whatif-scatter');
        }
      });
    });

    function normalizeKey(value) {
      return value != null ? String(value).trim() : '';
    }

    function getNumber(val) {
      if (val === null || val === undefined || val === '') return 0;
      const num = Number(val);
      return Number.isFinite(num) ? num : 0;
    }

    function formatCHF(value) {
      return new Intl.NumberFormat('de-CH', { style: 'currency', currency: 'CHF', minimumFractionDigits: 2 }).format(value || 0);
    }

    function hexToRgba(hex, alpha = 1) {
      const sanitized = hex.replace('#', '');
      const bigint = parseInt(sanitized.length === 3 ? sanitized.split('').map(c => c + c).join('') : sanitized, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    async function onFileSelected(event) {
      const file = event.target.files[0];
      if (!file) return;
      const name = file.name.toLowerCase();
      try {
        if (name.endsWith('.xlsx') || name.endsWith('.xls')) {
          await loadWorkbook(file);
        } else if (name.endsWith('.csv')) {
          const text = await file.text();
          const result = Papa.parse(text, { header: true, skipEmptyLines: true });
          state.data = { Rows: result.data };
          afterDataLoaded(true);
        } else if (name.endsWith('.zip')) {
          await loadZipOfCSVs(file);
        } else {
          alert('Unsupported file type. Please upload .xlsx, .zip, or .csv.');
        }
      } catch (err) {
        console.error(err);
        alert('Failed to load file: ' + err.message);
      }
    }

    async function loadWorkbook(file) {
      const arrayBuffer = await file.arrayBuffer();
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });
      const sheets = {};
      workbook.SheetNames.forEach(name => {
        const worksheet = workbook.Sheets[name];
        if (!worksheet) return;
        const rows = XLSX.utils.sheet_to_json(worksheet, { defval: null });
        sheets[name.replace(/\s+/g, '')] = rows;
      });
      state.data = sheets;
      afterDataLoaded();
    }

    async function loadZipOfCSVs(file) {
      const arrayBuffer = await file.arrayBuffer();
      const zip = await JSZip.loadAsync(arrayBuffer);
      const sheets = {};
      const entries = Object.keys(zip.files);
      for (const key of entries) {
        if (!key.toLowerCase().endsWith('.csv')) continue;
        const content = await zip.files[key].async('string');
        const parsed = Papa.parse(content, { header: true, skipEmptyLines: true });
        const sheetName = key.split('/').pop().replace(/\.csv$/i, '');
        sheets[sheetName] = parsed.data;
      }
      state.data = sheets;
      afterDataLoaded();
    }

    function afterDataLoaded(simple = false) {
      state.warnings = [];
      if (!simple) {
        const missing = requiredSheets.filter(name => !state.data[name]);
        if (missing.length) {
          state.warnings.push('Missing sheets: ' + missing.join(', '));
        }
      }
      initializeScenarioOptions();
      initializeAssemblyOptions();
      initializeTariffTable();
      populateSKUSelect();
      renderFXTable();
      recomputeAndRender();
    }

    function initializeScenarioOptions() {
      const container = document.getElementById('scenario-options');
      container.innerHTML = '';
      const scenarios = state.data.TariffScenarios || [];
      if (!scenarios.length) {
        container.innerHTML = '<span style="font-size:0.85rem; color:var(--muted);">No scenarios available.</span>';
        state.selection.scenarioDate = null;
        return;
      }
      scenarios.forEach((row, idx) => {
        const date = row.ScenarioDate || row.Date || row.Label;
        if (!date) return;
        const desc = row.Description || '';
        const checked = idx === 0 && !state.selection.scenarioDate;
        if (checked) state.selection.scenarioDate = date;
        const wrapper = document.createElement('label');
        wrapper.innerHTML = `<input type="radio" name="scenario" value="${date}"> <span>${date}${desc ? ' – ' + desc : ''}</span>`;
        const input = wrapper.querySelector('input');
        input.checked = state.selection.scenarioDate === date || checked;
        input.addEventListener('change', () => {
          state.selection.scenarioDate = date;
          recomputeAndRender();
        });
        container.appendChild(wrapper);
      });
    }

    function initializeAssemblyOptions() {
      const container = document.getElementById('assembly-options');
      container.innerHTML = '';
      const assemblySites = ['BU_CH_MUR', 'PLANT_US_MI', 'PLANT_MX_NL'];
      assemblySites.forEach(siteId => {
        const site = findSite(siteId);
        const label = site ? `${site.SiteID} (${site.Country || ''})` : siteId;
        const wrapper = document.createElement('label');
        wrapper.innerHTML = `<input type="radio" name="assembly" value="${siteId}"> <span>${label}</span>`;
        const input = wrapper.querySelector('input');
        if (!state.selection.assemblySite) state.selection.assemblySite = siteId;
        input.checked = state.selection.assemblySite === siteId;
        input.addEventListener('change', () => {
          state.selection.assemblySite = siteId;
          recomputeAndRender();
        });
        container.appendChild(wrapper);
      });
    }

    function findSite(siteId) {
      const sites = state.data.Sites || [];
      return sites.find(site => normalizeKey(site.SiteID) === normalizeKey(siteId));
    }

    function initializeTariffTable() {
      const container = document.getElementById('tariff-table');
      const rows = (state.data.TariffInputs || []).map((row, idx) => ({
        id: idx,
        ScenarioDateDefault: row.ScenarioDateDefault || '',
        ComponentClass: row.ComponentClass || row.Class || '',
        OriginCountry: row.OriginCountry || row.Country || '',
        DefaultRate_pct: getNumber(row.DefaultRate_pct || row.DefaultRate || 0),
        UserRate_pct: row.UserRate_pct !== undefined && row.UserRate_pct !== null ? Number(row.UserRate_pct) : null,
        Editable: row.Editable !== false
      }));
      state.overrideMap.clear();
      rows.forEach(row => {
        if (row.UserRate_pct !== null && !Number.isNaN(row.UserRate_pct)) {
          const key = normalizeKey(row.ComponentClass) + '|' + normalizeKey(row.OriginCountry);
          state.overrideMap.set(key, Number(row.UserRate_pct));
        }
      });
      if (state.tables.tariff) {
        state.tables.tariff.replaceData(rows);
      } else {
        state.tables.tariff = new Tabulator(container, {
          data: rows,
          layout: 'fitColumns',
          reactiveData: true,
          columns: [
            { title: 'Component Class', field: 'ComponentClass', width: 120 },
            { title: 'Origin', field: 'OriginCountry', width: 120 },
            { title: 'Default %', field: 'DefaultRate_pct', formatter: 'money', formatterParams: { precision: 1, symbol: '', thousand: "'" } },
            { title: 'Override %', field: 'UserRate_pct', editor: 'number', mutatorEdit: (value) => value === '' ? null : Number(value), formatter: cell => {
              const val = cell.getValue();
              return val === null || val === undefined ? '—' : `${Number(val).toFixed(1)}%`;
            } }
          ],
          rowFormatter: function(row) {
            if (!row.getData().Editable) {
              row.getElement().style.opacity = 0.6;
            }
          }
        });
        state.tables.tariff.on('cellEdited', function(cell) {
          const data = cell.getRow().getData();
          const key = normalizeKey(data.ComponentClass) + '|' + normalizeKey(data.OriginCountry);
          if (data.UserRate_pct === null || data.UserRate_pct === undefined || Number.isNaN(data.UserRate_pct)) {
            state.overrideMap.delete(key);
          } else {
            state.overrideMap.set(key, Number(data.UserRate_pct));
          }
          const inputs = state.data.TariffInputs || [];
          const original = inputs[cell.getRow().getIndex()];
          if (original) {
            original.UserRate_pct = data.UserRate_pct;
          }
          recomputeAndRender();
        });
      }
    }

    function resetOverrides() {
      const inputs = state.data.TariffInputs || [];
      inputs.forEach(row => {
        if (row) row.UserRate_pct = null;
      });
      if (state.tables.tariff) {
        state.tables.tariff.getRows().forEach(row => {
          const data = row.getData();
          data.UserRate_pct = null;
          row.update(data);
        });
      }
      state.overrideMap.clear();
      recomputeAndRender();
    }

    function populateSKUSelect() {
      const select = document.getElementById('sku-select');
      select.innerHTML = '';
      const products = state.data.Products || [];
      const optionAll = document.createElement('option');
      optionAll.value = 'ALL';
      optionAll.textContent = 'All SKUs';
      select.appendChild(optionAll);
      products.forEach(product => {
        const sku = product.SKU || product.Product || product.ParentSKU;
        if (!sku) return;
        const option = document.createElement('option');
        option.value = sku;
        option.textContent = `${sku} – ${product.Description || ''}`;
        select.appendChild(option);
      });
      if (!state.selection.sku) state.selection.sku = 'ALL';
      select.value = state.selection.sku;
    }

    function renderFXTable() {
      const table = document.getElementById('fx-table');
      const fx = state.data.FX || [];
      if (!fx.length) {
        table.innerHTML = '<tr><td style="color:var(--muted);">FX sheet missing.</td></tr>';
        return;
      }
      table.innerHTML = '<tr><th>Currency</th><th>Value vs CHF baseline</th></tr>';
      fx.forEach(row => {
        const currency = row.Currency || row.Code || '';
        const rate = row.USD_per_unit || row.CHF_per_unit || row.Rate;
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${currency}</td><td>${rate ?? '—'}</td>`;
        table.appendChild(tr);
      });
    }

    function recomputeAndRender() {
      state.model = computeModel();
      renderAll();
    }

    function renderAll() {
      renderWarnings();
      renderKPIs();
      renderCostChart();
      renderSkuTable();
      renderMap();
      renderWhatIf();
      updateCounts();
      updateInsights();
    }

    function renderWarnings() {
      const container = document.getElementById('warnings');
      container.innerHTML = '';
      const warnings = [...(state.warnings || []), ...((state.model && state.model.warnings) || [])];
      if (!warnings.length) {
        container.innerHTML = '<span style="color:var(--muted);">None</span>';
        return;
      }
      warnings.forEach(msg => {
        const div = document.createElement('div');
        div.textContent = msg;
        container.appendChild(div);
      });
    }

    function updateCounts() {
      const counts = document.getElementById('row-counts');
      if (!state.model) {
        counts.textContent = 'Waiting for data…';
        return;
      }
      counts.textContent = `${state.model.perSku.length} SKU rows · ${state.model.componentCount} components`;
    }

    function computeModel() {
      const model = {
        perSku: [],
        assemblyComparison: {},
        warnings: [],
        mapFlows: [],
        componentCount: 0
      };
      const data = state.data;
      if (!data.Products || !data.BOM || !data.Components) {
        model.warnings.push('Products, BOM, or Components sheet missing.');
        return model;
      }
      const scenario = state.selection.scenarioDate;
      const includeFixed = state.selection.includeFixedFees;
      const motorOverride = state.selection.motorRoute;

      const products = data.Products;
      const bomRows = data.BOM;
      const components = data.Components;
      const sites = data.Sites || [];
      const assemblyOptions = data.AssemblyOptions || [];
      const logistics = data.LogisticsLanes || [];
      const tariffs = data.Tariffs_US || [];
      const tariffInputs = data.TariffInputs || [];

      const componentIndex = new Map();
      components.forEach(component => {
        const id = normalizeKey(component.PartID || component.ComponentID || component.ID);
        if (id) componentIndex.set(id, component);
      });
      const siteIndex = new Map();
      sites.forEach(site => {
        const id = normalizeKey(site.SiteID || site.ID);
        if (id) siteIndex.set(id, site);
      });
      const lanesIndex = new Map();
      logistics.forEach(lane => {
        const key = `${normalizeKey(lane.FromCountry || lane.OriginCountry)}|${normalizeKey(lane.ToCountry || lane.DestinationCountry)}`;
        lanesIndex.set(key, lane);
      });
      const assemblyIndex = new Map();
      assemblyOptions.forEach(row => {
        const sku = normalizeKey(row.SKU || row.ParentSKU);
        if (!assemblyIndex.has(sku)) assemblyIndex.set(sku, []);
        assemblyIndex.get(sku).push(row);
      });
      const tariffScenarioIndex = new Map();
      tariffs.forEach(row => {
        const date = normalizeKey(row.ScenarioDate || row.Date || row.Scenario);
        const classKey = normalizeKey(row.ComponentClass || row.Class || row.Type);
        const origin = normalizeKey(row.OriginCountry || row.Country);
        const key = `${classKey}|${origin}`;
        if (!tariffScenarioIndex.has(date)) tariffScenarioIndex.set(date, new Map());
        tariffScenarioIndex.get(date).set(key, Number(row.US_AdValoremTariff_pct || row.Tariff_pct || row.Rate || 0));
      });
      const overrideMap = new Map(state.overrideMap);
      tariffInputs.forEach(row => {
        const classKey = normalizeKey(row.ComponentClass || row.Class || '');
        const origin = normalizeKey(row.OriginCountry || row.Country || '');
        if (!classKey || !origin) return;
        const key = `${classKey}|${origin}`;
        if (row.UserRate_pct !== undefined && row.UserRate_pct !== null && row.UserRate_pct !== '') {
          overrideMap.set(key, Number(row.UserRate_pct));
        }
      });

      const allAssemblySites = ['BU_CH_MUR', 'PLANT_US_MI', 'PLANT_MX_NL'];

      products.forEach(product => {
        const sku = normalizeKey(product.SKU || product.Product || product.ParentSKU);
        if (!sku) return;
        const availableAssembly = assemblyIndex.get(sku) || [];
        const listPrice = getNumber(product.ListPrice_CHF || product.ListPrice || product.ListPrice_USD || product.Price_CHF);
        const productWeight = getNumber(product.UnitWeight_kg || product.Weight_kg || product.UnitWeightKg || 0);

        const perAssembly = [];
        allAssemblySites.forEach(siteIdRaw => {
          const siteId = normalizeKey(siteIdRaw);
          const option = availableAssembly.find(opt => normalizeKey(opt.AssemblySiteID) === siteId);
          if (!option) return;
          const assemblySite = siteIndex.get(siteId) || { Country: 'United States', SiteID: siteId };
          const assemblyCountry = assemblySite.Country || assemblySite.CountryName || 'United States';
          const yieldFactor = getNumber(option.Yield) || 1;
          const conversionCost = getNumber(option.BaseConvCost_CHF || option.BaseConvCost || option.BaseConvCost_USD);
          const bomLines = bomRows.filter(row => normalizeKey(row.ParentSKU || row.SKU) === sku);
          const componentBreakdown = [];
          let materialCost = 0;
          let logisticsCost = 0;
          let tariffCost = 0;
          let leadTime = 0;

          bomLines.forEach(bom => {
            const compId = normalizeKey(bom.PartID || bom.ComponentID || bom.Component);
            if (!compId) return;
            const comp = componentIndex.get(compId);
            if (!comp) {
              model.warnings.push(`Component ${compId} missing in Components sheet.`);
              return;
            }
            const qty = getNumber(bom.Qty || bom.Quantity || bom.QtyPer || 0);
            const compClass = normalizeKey(comp.Class || comp.ComponentClass || '');
            const unitWeight = getNumber(comp.UnitWeight_kg || comp.UnitWeight || comp.Weight_kg || 0);
            const originSiteId = normalizeKey(comp.OriginSiteID || comp.SiteID || '');
            const originSite = siteIndex.get(originSiteId);
            let originCountry = originSite ? (originSite.Country || originSite.CountryName || '') : (comp.OriginCountry || comp.Country || '');
            if (!originCountry) originCountry = 'Unknown';
            if (motorOverride !== 'default' && /motor/i.test(compClass || comp.Description || compId)) {
              originCountry = motorOverride;
            }
            const customsValue = getNumber(comp.BasePrice_CHF || comp.BasePrice || comp.BasePrice_local || comp.Price_CHF);
            const valuePerSku = qty * customsValue / (yieldFactor || 1);
            materialCost += valuePerSku;

            const laneKey = `${normalizeKey(originCountry)}|${normalizeKey(assemblyCountry)}`;
            const lane = lanesIndex.get(laneKey);
            const legCostPerKg = lane ? getNumber(lane.Cost_per_kg_CHF || lane.Cost_per_kg || lane.Cost_per_kg_USD) : 0;
            const fixedPerShipment = lane ? getNumber(lane.Fixed_per_shipment_CHF || lane.Fixed_per_shipment || lane.Fixed_per_shipment_USD) : 0;
            const lead = lane ? getNumber(lane.LeadTime_days || lane.LeadTime) : 0;
            const componentWeight = unitWeight * qty;
            const legCost = legCostPerKg * componentWeight;
            const fixedCost = includeFixed ? (fixedPerShipment * (qty / 10000)) : 0;
            logisticsCost += legCost + fixedCost;
            leadTime += lead;

            const tariffRate = resolveTariffRate(compClass, originCountry, scenario, overrideMap, tariffScenarioIndex);
            const componentTariff = valuePerSku * (tariffRate / 100);
            tariffCost += componentTariff;

            componentBreakdown.push({
              componentId: compId,
              componentClass: compClass,
              originCountry,
              assemblyCountry,
              customsValue: valuePerSku,
              tariffRate,
              tariffCost: componentTariff,
              logisticsCost: legCost + fixedCost,
              materialCost: valuePerSku,
              leadTime: lead
            });
          });

          let finalLegCost = 0;
          let finalLegLead = 0;
          let finalAssemblyTariff = 0;
          if (normalizeKey(assemblyCountry) !== 'united states') {
            const finalLane = lanesIndex.get(`${normalizeKey(assemblyCountry)}|united states`);
            if (finalLane) {
              const costPerKg = getNumber(finalLane.Cost_per_kg_CHF || finalLane.Cost_per_kg || finalLane.Cost_per_kg_USD);
              const fixedPerShipment = getNumber(finalLane.Fixed_per_shipment_CHF || finalLane.Fixed_per_shipment || finalLane.Fixed_per_shipment_USD);
              const lead = getNumber(finalLane.LeadTime_days || finalLane.LeadTime);
              finalLegCost = costPerKg * productWeight + (includeFixed ? (fixedPerShipment * (1 / 10000)) : 0);
              finalLegLead = lead;
              logisticsCost += finalLegCost;
              leadTime += finalLegLead;
            } else {
              model.warnings.push(`Missing logistics lane ${assemblyCountry} → United States.`);
            }
            const finalTariffRate = resolveTariffRate('FinalAssembly', assemblyCountry, scenario, overrideMap, tariffScenarioIndex);
            finalAssemblyTariff = (materialCost + conversionCost) * (finalTariffRate / 100);
            tariffCost += finalAssemblyTariff;
            componentBreakdown.push({
              componentId: 'FinalAssembly',
              componentClass: 'FinalAssembly',
              originCountry: assemblyCountry,
              assemblyCountry: 'United States',
              customsValue: materialCost + conversionCost,
              tariffRate: finalTariffRate,
              tariffCost: finalAssemblyTariff,
              logisticsCost: finalLegCost,
              materialCost: 0,
              leadTime: finalLegLead
            });
          }

          const landedCost = materialCost + logisticsCost + tariffCost + conversionCost;
          const margin = listPrice - landedCost;
          const marginPct = listPrice ? (margin / listPrice) * 100 : 0;
          const result = {
            SKU: sku,
            Description: product.Description || '',
            AssemblySiteID: siteId,
            AssemblyCountry: assemblyCountry,
            MaterialCost_CHF: materialCost,
            LogisticsCost_CHF: logisticsCost,
            TariffCost_CHF: tariffCost,
            ConversionCost_CHF: conversionCost,
            LandedCost_CHF: landedCost,
            ListPrice_CHF: listPrice,
            Margin_CHF: margin,
            MarginPct: marginPct,
            LeadTime_days: leadTime,
            componentBreakdown
          };
          perAssembly.push(result);
          model.mapFlows.push({ sku, assemblyCountry, breakdown: componentBreakdown, landedCost });
        });

        const selectedAssemblyId = normalizeKey(state.selection.assemblySite);
        const selected = perAssembly.find(row => normalizeKey(row.AssemblySiteID) === selectedAssemblyId) || perAssembly[0];
        if (selected) {
          model.perSku.push(selected);
          model.componentCount += selected.componentBreakdown.filter(item => item.componentId !== 'FinalAssembly').length;
        }
        perAssembly.forEach(entry => {
          if (!model.assemblyComparison[entry.AssemblySiteID]) {
            model.assemblyComparison[entry.AssemblySiteID] = { material: 0, logistics: 0, tariffs: 0, conversion: 0 };
          }
          model.assemblyComparison[entry.AssemblySiteID].material += entry.MaterialCost_CHF;
          model.assemblyComparison[entry.AssemblySiteID].logistics += entry.LogisticsCost_CHF;
          model.assemblyComparison[entry.AssemblySiteID].tariffs += entry.TariffCost_CHF;
          model.assemblyComparison[entry.AssemblySiteID].conversion += entry.ConversionCost_CHF;
        });
      });

      model.warnings = Array.from(new Set(model.warnings));
      return model;
    }

    function resolveTariffRate(componentClass, originCountry, scenario, overrideMap, tariffScenarioIndex) {
      const classKey = normalizeKey(componentClass);
      const originKey = normalizeKey(originCountry);
      const lookupKey = `${classKey}|${originKey}`;
      if (overrideMap.has(lookupKey)) {
        return Number(overrideMap.get(lookupKey)) || 0;
      }
      if (scenario) {
        const scenarioMap = tariffScenarioIndex.get(normalizeKey(scenario));
        if (scenarioMap && scenarioMap.has(lookupKey)) {
          return Number(scenarioMap.get(lookupKey)) || 0;
        }
      }
      const inputs = state.data.TariffInputs || [];
      const match = inputs.find(row => normalizeKey(row.ComponentClass || row.Class || '') === classKey && normalizeKey(row.OriginCountry || row.Country || '') === originKey && row.DefaultRate_pct !== undefined);
      if (match) return Number(match.DefaultRate_pct) || 0;
      return 0;
    }

    function renderKPIs() {
      const container = document.getElementById('kpi-grid');
      container.innerHTML = '';
      if (!state.model || !state.model.perSku.length) {
        container.innerHTML = '<div class="kpi-tile"><div class="kpi-label">Status</div><div class="kpi-value" style="color:var(--muted);">Awaiting data</div></div>';
        return;
      }
      const selectedSKU = state.selection.sku;
      const rows = selectedSKU === 'ALL' ? state.model.perSku : state.model.perSku.filter(row => row.SKU === selectedSKU);
      if (!rows.length) {
        container.innerHTML = '<div class="kpi-tile"><div class="kpi-label">Status</div><div class="kpi-value" style="color:var(--muted);">No rows</div></div>';
        return;
      }
      const aggregate = rows.reduce((acc, row) => {
        acc.landed += row.LandedCost_CHF;
        acc.margin += row.Margin_CHF;
        acc.list += row.ListPrice_CHF;
        return acc;
      }, { landed:0, margin:0, list:0 });
      const landedValue = rows.length === 1 ? rows[0].LandedCost_CHF : aggregate.landed;
      const marginValue = rows.length === 1 ? rows[0].Margin_CHF : aggregate.margin;
      const marginPct = aggregate.list ? (aggregate.margin / aggregate.list) * 100 : (rows[0] ? rows[0].MarginPct : 0);
      const kpis = [
        { label: 'Landed cost', value: formatCHF(landedValue) },
        { label: 'Margin', value: formatCHF(marginValue) },
        { label: 'Margin %', value: `${marginPct.toFixed(1)}%` }
      ];
      kpis.forEach(kpi => {
        const tile = document.createElement('div');
        tile.className = 'kpi-tile';
        tile.innerHTML = `<div class="kpi-label">${kpi.label}</div><div class="kpi-value">${kpi.value}</div>`;
        container.appendChild(tile);
      });
    }

    function renderCostChart() {
      const containerId = 'cost-chart';
      if (!state.model || !Object.keys(state.model.assemblyComparison).length) {
        Plotly.purge(containerId);
        return;
      }
      const sites = Object.keys(state.model.assemblyComparison);
      const categories = ['material','logistics','tariffs','conversion'];
      const traces = categories.map((key, idx) => {
        return {
          type: 'bar',
          orientation: 'h',
          name: key.charAt(0).toUpperCase() + key.slice(1),
          x: sites.map(site => state.model.assemblyComparison[site][key]),
          y: sites.map(site => site),
          marker: { color: ['#c98c60','#7fa1d2','#b46c6c','#9fc69d'][idx] }
        };
      });
      const layout = {
        barmode: 'stack',
        margin: { l: 140, r: 30, t: 10, b: 40 },
        height: Math.max(320, sites.length * 40 + 120),
        legend: { orientation: 'h', x: 0, y: 1.1 },
        xaxis: { title: 'CHF', tickprefix: 'CHF ' },
        yaxis: { automargin: true }
      };
      Plotly.react(containerId, traces, layout, { displaylogo: false, responsive: true });
      const legend = document.getElementById('assembly-legend');
      legend.innerHTML = '';
      sites.forEach(site => {
        const color = state.colors[site] || '#666';
        const span = document.createElement('span');
        span.innerHTML = `<span class="color-box" style="background:${color}"></span>${site}`;
        legend.appendChild(span);
      });
    }

    function renderSkuTable() {
      if (!state.model) return;
      const rows = state.selection.sku === 'ALL' ? state.model.perSku : state.model.perSku.filter(row => row.SKU === state.selection.sku);
      const data = rows.map(row => ({
        SKU: row.SKU,
        AssemblySiteID: row.AssemblySiteID,
        AssemblyCountry: row.AssemblyCountry,
        MaterialCost_CHF: row.MaterialCost_CHF,
        LogisticsCost_CHF: row.LogisticsCost_CHF,
        TariffCost_CHF: row.TariffCost_CHF,
        ConversionCost_CHF: row.ConversionCost_CHF,
        LandedCost_CHF: row.LandedCost_CHF,
        ListPrice_CHF: row.ListPrice_CHF,
        Margin_CHF: row.Margin_CHF,
        MarginPct: row.MarginPct
      }));
      const columns = [
        { title: 'SKU', field: 'SKU', width: 140 },
        { title: 'Assembly Site', field: 'AssemblySiteID', width: 140 },
        { title: 'Assembly Country', field: 'AssemblyCountry', width: 140 },
        { title: 'Material (CHF)', field: 'MaterialCost_CHF', formatter: currencyFormatter },
        { title: 'Logistics (CHF)', field: 'LogisticsCost_CHF', formatter: currencyFormatter },
        { title: 'Tariffs (CHF)', field: 'TariffCost_CHF', formatter: currencyFormatter },
        { title: 'Conversion (CHF)', field: 'ConversionCost_CHF', formatter: currencyFormatter },
        { title: 'Landed (CHF)', field: 'LandedCost_CHF', formatter: currencyFormatter },
        { title: 'List Price (CHF)', field: 'ListPrice_CHF', formatter: currencyFormatter },
        { title: 'Margin (CHF)', field: 'Margin_CHF', formatter: currencyFormatter },
        { title: 'Margin %', field: 'MarginPct', formatter: pctFormatter }
      ];
      if (state.tables.sku) {
        state.tables.sku.replaceData(data);
      } else {
        state.tables.sku = new Tabulator('#sku-table', {
          data,
          layout: 'fitDataStretch',
          selectable: false,
          pagination: false,
          columns,
          height: 360,
          reactiveData: true
        });
      }
    }

    function currencyFormatter(cell) {
      const value = cell.getValue();
      return formatCHF(value);
    }
    function pctFormatter(cell) {
      const value = cell.getValue();
      if (value === null || value === undefined) return '—';
      return value.toFixed(1) + '%';
    }

    function triggerDownload(format) {
      if (!state.tables.sku) {
        alert('No data to download.');
        return;
      }
      if (format === 'csv') {
        state.tables.sku.download('csv', 'tariff_dashboard.csv');
      } else if (format === 'xlsx') {
        state.tables.sku.download('xlsx', 'tariff_dashboard.xlsx', { sheetName: 'LandedCost' });
      }
    }

    function renderMap() {
      const containerId = 'map-chart';
      if (!state.model || !state.model.mapFlows.length || !state.data.MapNodes) {
        Plotly.purge(containerId);
        return;
      }
      const nodes = state.data.MapNodes;
      const nodeIndex = new Map();
      nodes.forEach(node => {
        const id = normalizeKey(node.SiteID || node.ID || node.Name);
        if (id) nodeIndex.set(id, node);
      });

      const traces = [];
      const flows = [];
      state.model.perSku.forEach(row => {
        let finalEntry = null;
        row.componentBreakdown.forEach(component => {
          if (component.componentId === 'FinalAssembly') {
            finalEntry = component;
            return;
          }
          const originCountry = component.originCountry;
          const assemblyCountry = row.AssemblyCountry;
          const originNode = nodes.find(node => normalizeKey(node.Country) === normalizeKey(originCountry));
          const assemblyNode = nodes.find(node => normalizeKey(node.Country) === normalizeKey(assemblyCountry));
          const shareToAssemblyRaw = row.LandedCost_CHF ? (component.materialCost + component.logisticsCost + component.tariffCost) / row.LandedCost_CHF : 0;
          const shareToAssembly = Math.max(0, Math.min(1, shareToAssemblyRaw));
          if (originNode && assemblyNode) {
            flows.push({
              from: originNode,
              to: assemblyNode,
              share: shareToAssembly,
              label: `${component.componentClass || component.componentId}\nTariff ${component.tariffRate.toFixed(1)}%`,
              assembly: row.AssemblySiteID
            });
          }
        });
        const assemblyNode = nodes.find(node => normalizeKey(node.Country) === normalizeKey(row.AssemblyCountry));
        const usNode = nodes.find(node => /united states/i.test(node.Country));
        if (finalEntry && assemblyNode && usNode && normalizeKey(row.AssemblyCountry) !== 'united states') {
          const shareToUSRaw = row.LandedCost_CHF ? (finalEntry.logisticsCost + finalEntry.tariffCost) / row.LandedCost_CHF : 0;
          const shareToUS = Math.max(0, Math.min(1, shareToUSRaw));
          flows.push({
            from: assemblyNode,
            to: usNode,
            share: shareToUS,
            label: `Final shipment\nTariff ${finalEntry.tariffRate.toFixed(1)}%`,
            assembly: row.AssemblySiteID
          });
        }
      });

      flows.forEach(flow => {
        traces.push({
          type: 'scattergeo',
          mode: 'lines',
          lon: [flow.from.Lon, flow.to.Lon],
          lat: [flow.from.Lat, flow.to.Lat],
          line: {
            width: Math.max(1, flow.share * 8),
            color: hexToRgba(state.colors[flow.assembly] || '#a86d3d', Math.min(0.85, 0.35 + flow.share))
          },
          hoverinfo: 'text',
          text: `${flow.from.Country} → ${flow.to.Country}\nShare ${(flow.share * 100).toFixed(1)}%\n${flow.label}`
        });
      });

      const nodeTrace = {
        type: 'scattergeo',
        mode: 'markers+text',
        text: nodes.map(node => `${node.SiteID}\n${node.Country}`),
        lon: nodes.map(node => node.Lon),
        lat: nodes.map(node => node.Lat),
        marker: { size: 8, color: '#5a6cb2' },
        textposition: 'top center',
        hoverinfo: 'text'
      };
      traces.push(nodeTrace);

      const layout = {
        geo: {
          projection: { type: 'natural earth' },
          showcountries: true,
          showland: true,
          landcolor: '#f7efe7',
          countrycolor: '#bfbfbf'
        },
        margin: { l: 0, r: 0, t: 0, b: 0 }
      };
      Plotly.react(containerId, traces, layout, { displaylogo: false, responsive: true });
    }

    function renderWhatIf() {
      const containerId = 'whatif-scatter';
      if (!state.model || !state.model.perSku.length) {
        Plotly.purge(containerId);
        return;
      }
      const data = state.model.perSku.map(row => ({
        x: row.LeadTime_days,
        y: row.MarginPct,
        text: `${row.SKU}\n${row.AssemblySiteID}`,
        sku: row.SKU,
        assembly: row.AssemblySiteID
      }));
      const trace = {
        type: 'scatter',
        mode: 'markers',
        x: data.map(d => d.x),
        y: data.map(d => d.y),
        text: data.map(d => d.text),
        marker: {
          size: 12,
          color: data.map(d => state.colors[d.assembly] || '#666')
        }
      };
      const layout = {
        margin: { l: 50, r: 20, t: 20, b: 50 },
        xaxis: { title: 'Lead time (days)' },
        yaxis: { title: 'Margin %' }
      };
      Plotly.react(containerId, [trace], layout, { displaylogo: false, responsive: true });
    }

    function updateInsights() {
      const container = document.getElementById('insights-text');
      if (!state.model || !Object.keys(state.model.assemblyComparison).length) {
        container.textContent = 'Upload a workbook to explore landed cost insights.';
        return;
      }
      const assemblyEntries = Object.entries(state.model.assemblyComparison).map(([site, values]) => {
        const total = values.material + values.logistics + values.tariffs + values.conversion;
        return { site, total };
      });
      assemblyEntries.sort((a,b) => a.total - b.total);
      if (assemblyEntries.length < 2) {
        container.textContent = `Selected assembly site ${assemblyEntries[0].site} yields landed cost of ${formatCHF(assemblyEntries[0].total)}.`;
        return;
      }
      const best = assemblyEntries[0];
      const worst = assemblyEntries[assemblyEntries.length - 1];
      const diffPct = ((worst.total - best.total) / best.total) * 100;
      container.textContent = `${best.site} has the lowest landed cost (${formatCHF(best.total)}). ${worst.site} is higher by ${diffPct.toFixed(1)}%. Toggle motor routing to see potential improvements.`;
    }
  </script>
</body>
</html>
